# Стратегия Ветвления Проекта (GitFlow)

Этот документ описывает стратегию ветвления, используемую в данном проекте. Мы придерживаемся модели GitFlow, которая хорошо подходит для проектов с запланированными релизами.

## Основные Ветви

Существуют две основные ветви с бесконечным временем жизни:

*   `main` (или `master`): Эта ветвь отражает последний стабильный релизный код. Прямые коммиты в `main` запрещены. Код в `main` должен быть всегда готов к развертыванию. Каждый коммит в `main` является новым релизом и должен быть помечен соответствующим тегом.
*   `develop`: Эта ветвь является основной веткой для разработки и интеграции нового функционала. Она содержит последние изменения, которые были разработаны и протестированы. Ночной билд (если настроен) обычно собирается из этой ветки. Когда `develop` достигает стабильного состояния и готова к релизу, она сливается в `main`.

## Вспомогательные Ветви

В дополнение к основным ветвям, используются следующие типы вспомогательных ветвей. Эти ветви имеют ограниченное время жизни и удаляются после завершения их цели.

### 1. Ветви Функционала (`feature/*`)

*   **Назначение:** Разработка нового функционала.
*   **Ответвляются от:** `develop`
*   **Сливаются в:** `develop`
*   **Именование:** `feature/<название-функционала>` (например, `feature/user-authentication`, `feature/kml-parser`)
*   **Рабочий процесс:**
    1.  Для разработки новой функциональности создается ветка `feature/*` от `develop`.
    2.  Разработчик работает в этой ветке, делая коммиты.
    3.  После завершения разработки и локального тестирования, ветка `feature/*` сливается обратно в `develop` (обычно через Pull Request/Merge Request с обязательным код-ревью).
    4.  После успешного слияния ветка `feature/*` может быть удалена.

### 2. Релизные Ветви (`release/*`)

*   **Назначение:** Подготовка нового релиза. Позволяет отделить подготовку релиза от основной разработки в `develop`. В этой ветке выполняются только исправления багов, относящихся к релизу, обновление документации и другие задачи, связанные с подготовкой релиза.
*   **Ответвляются от:** `develop`
*   **Сливаются в:** `main` и `develop`
*   **Именование:** `release/<версия>` (например, `release/v1.0.0`, `release/v0.2.1`)
*   **Рабочий процесс:**
    1.  Когда ветка `develop` содержит достаточно функционала для нового релиза (или приближается запланированная дата релиза), от `develop` создается ветка `release/*`.
    2.  С этого момента в `release/*` допускаются только исправления багов, специфичных для этого релиза, и обновление мета-информации (версия, дата сборки и т.д.). Новый функционал в `release/*` не добавляется.
    3.  После того как ветка `release/*` стабилизирована и готова к выпуску, она сливается в `main`. Каждый коммит в `main` должен быть помечен тегом с номером версии.
    4.  Затем изменения из `release/*` (исправления багов, сделанные во время подготовки релиза) должны быть слиты обратно в `develop`, чтобы они не потерялись для будущих релизов.
    5.  После слияния в `main` и `develop`, ветка `release/*` может быть удалена.

### 3. Ветви Исправлений (`hotfix/*`)

*   **Назначение:** Срочное исправление критических багов в продакшн-коде (в ветке `main`).
*   **Ответвляются от:** `main` (от конкретного тега релиза, в котором обнаружен баг)
*   **Сливаются в:** `main` и `develop`
*   **Именование:** `hotfix/<описание-исправления>` или `hotfix/<версия-исправления>` (например, `hotfix/login-issue`, `hotfix/v1.0.1`)
*   **Рабочий процесс:**
    1.  Если в релизной версии (`main`) обнаруживается критический баг, который требует немедленного исправления, от соответствующего тега в `main` создается ветка `hotfix/*`.
    2.  В этой ветке производится необходимое исправление.
    3.  После завершения и тестирования исправления, ветка `hotfix/*` сливается в `main`. Этот коммит в `main` также должен быть помечен новым тегом (например, инкрементируется патч-версия).
    4.  Изменения из `hotfix/*` также должны быть слиты в `develop` (или в текущую активную ветку `release/*`, если она существует), чтобы исправление было включено в будущие релизы.
    5.  После слияния ветка `hotfix/*` может быть удалена.

## Соглашения о Комментариях к Коммитам (Commit Messages)

Для обеспечения единообразия и читаемости истории коммитов, мы придерживаемся стандарта [Conventional Commits](https://www.conventionalcommits.org/).

### Формат сообщения коммита:

```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

**Основные типы (`<type>`):**

*   `feat`: Новая функциональность для пользователя (соответствует `MINOR` в семантическом версионировании).
*   `fix`: Исправление ошибки для пользователя (соответствует `PATCH` в семантическом версионировании).
*   `docs`: Изменения только в документации.
*   `style`: Изменения, не влияющие на смысл кода (пробелы, форматирование, недостающие точки с запятой и т.д.).
*   `refactor`: Рефакторинг кода, который не исправляет ошибку и не добавляет новую функциональность.
*   `perf`: Изменение кода, улучшающее производительность.
*   `test`: Добавление недостающих тестов или исправление существующих.
*   `build`: Изменения, влияющие на систему сборки или внешние зависимости (например, Gulp, Broccoli, NPM).
*   `ci`: Изменения в файлах конфигурации CI и скриптах (например, Travis, Circle, BrowserStack, SauceLabs).
*   `chore`: Другие изменения, которые не модифицируют исходный код или тесты (например, обновление зависимостей).
*   `revert`: Откат предыдущего коммита.

**Область действия (`<scope>`):**

Опциональное поле, указывающее на часть кодовой базы, которую затронул коммит (например, `parser`, `api`, `ui`).

**Описание (`<description>`):**

Краткое описание изменения в настоящем времени, строчными буквами, без точки в конце.

**Тело (`<body>`):**

Более подробное описание изменений, если необходимо. Отделяется от заголовка пустой строкой.

**Нижний колонтитул (`<footer>`):**

Может содержать информацию о ломающих изменениях (`BREAKING CHANGE: <description>`) или ссылки на Issues (например, `Closes #123`).

**Примеры:**

```
feat: добавить возможность экспорта в CSV
```

```
fix(parser): исправить ошибку парсинга KML с пустыми тегами

Проблема возникала, когда в KML файле встречались теги координат без содержимого.
Closes #42
```

```
docs: обновить руководство пользователя разделом о CLI
```

### Процесс Коммита (согласно NFR-3)

1.  **Подготовка изменений:** Убедитесь, что все необходимые изменения готовы к коммиту.
2.  **Индексация (`git add`):** Перед созданием коммита выполните команду `git add .` (или укажите конкретные файлы), чтобы проиндексировать все изменения, которые должны войти в коммит.
3.  **Создание сообщения коммита во временном файле:**
    *   Создайте временный текстовый файл (например, `COMMIT_EDITMSG.tmp`).
    *   Напишите в нем сообщение коммита, следуя стандарту Conventional Commits.
4.  **Выполнение коммита:** Используйте команду `git commit -F COMMIT_EDITMSG.tmp`.
5.  **Удаление временного файла:** После успешного создания коммита удалите временный файл `COMMIT_EDITMSG.tmp`.

Этот процесс обеспечивает, что комментарии к коммитам будут осмысленными и хорошо оформленными.

## Стратегия Тегирования (Tagging Strategy)

Теги используются для отметки важных точек в истории проекта, в основном – релизов. Мы используем семантическое версионирование (`MAJOR.MINOR.PATCH`).

### 1. Теги Релизов (NFR-5)

*   **Назначение:** Отметка каждого официального релиза ПО.
*   **Формат:** `v<MAJOR>.<MINOR>.<PATCH>` (например, `v1.0.0`, `v0.2.1`, `v1.0.1-hotfix`).
*   **Тип тега:** Аннотированный (для включения описания релиза).
*   **Процесс:**
    1.  Теги релизов ставятся на коммиты в ветке `main`, которые являются результатом слияния ветки `release/*` или `hotfix/*`.
    2.  Команда для создания аннотированного тега релиза:
        ```bash
        git tag -a v1.0.0 -m "Релиз версии 1.0.0: Основной функционал получения данных и экспорта в GeoJSON."
        ```
    3.  После создания локального тега, его необходимо отправить на удаленный сервер:
        ```bash
        git push origin v1.0.0
        ```
        Или отправить все локальные теги:
        ```bash
        git push origin --tags
        ```

### 2. Теги для Крупных Разделов / Запросов Заказчика (NFR-4)

*   **Назначение:** Отметка завершения крупных этапов разработки или выполнения специфических запросов заказчика, которые могут не совпадать с официальным релизом, но представляют собой важные вехи.
*   **Формат:** `milestone/<название-вехи>` (например, `milestone/interactive-map-prototype`, `milestone/reporting-module-v1`).
*   **Тип тега:** Аннотированный (для включения подробного описания вехи и ее значимости).
*   **Процесс:**
    1.  Теги ставятся на соответствующий коммит в ветке `develop` (или другой релевантной ветке, где была завершена работа над вехой).
    2.  Аннотация должна подробно описывать, что было достигнуто на данной вехе.
    3.  Команда для создания аннотированного тега вехи:
        ```bash
        git tag -a milestone/initial-setup-complete -m "Завершение первоначальной настройки проекта: стратегия ветвления, коммитов, тегов, базовые файлы README, LICENSE, .gitignore."
        ```
    4.  Отправка на удаленный сервер (аналогично тегам релизов):
        ```bash
        git push origin milestone/initial-setup-complete
        ```

### Общие Рекомендации по Тегам

*   Теги являются неизменяемыми. Если тег был создан неправильно, его следует удалить и создать заново с корректной информацией, а не пытаться изменить существующий.
*   Подробно описывайте суть релиза или вехи в аннотации к тегу. 